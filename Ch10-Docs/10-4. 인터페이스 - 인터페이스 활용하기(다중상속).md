# 10-4. 인터페이스 - 인터페이스 활용하기

## 한 클래스가 여러 인터페이스를 구현하는 경우(다중 상속)

```java
package UseInterface;

public interface Buy {
    void buy();
}
//=========================================================
package UseInterface;

public interface Sell {
    void sell();
}
//=========================================================
package UseInterface;

public class Customer implements Buy, Sell{

    @Override
    public void buy() {
        System.out.println("구매");
    }

    @Override
    public void sell() {
        System.out.println("판매");
    }
}
//=========================================================
package UseInterface;

public class CustomerTest {
    public static void main(String[] args) {
        Customer customer = new Customer();

        Buy buyer = customer;
        buyer.buy();

        Sell seller = customer;
        seller.sell();

        if (seller instanceof Customer) {
            Customer customer2 = (Customer)seller;
            customer2.buy();
            customer2.sell();
        }
    }
}
```

## 두 인터페이스의 디폴트 메소드가 중복되는 경우

- 오버라이딩으로 해결

```java
public interface Buy {
    void buy();
    
    default void order(){
        System.out.println("구매 주문");
    }
}
//======================
public interface Sell {
    void sell();

    default void order(){
        System.out.println("판매 주문");
    }
}
//======================
public class Customer implements Buy, Sell{
  @Override
    public void order() {
        System.out.println("고객 판매 주문");
    }
}
```

## 인터페이스 상속하기(형상속. type inheritance)

- extends로 인터페이스 끼리 상속 가능
- 기능상 계층 구조가 필요한 경우 상속을 사용할 수 있습니다.

```java
package TypeInheritance;

public interface X {
    void x();
}
//=================================
package TypeInheritance;

public interface Y {
    void y();
}
//=================================
package TypeInheritance;

public interface MyInterface extends X,Y{
    void myMethod();
}
//==================================
package TypeInheritance;

public class MyClass implements MyInterface{

    @Override
    public void myMethod() {
        System.out.println("myMethod");
    }

    @Override
    public void x() {
        System.out.println("x()");
    }

    @Override
    public void y() {
        System.out.println("y()");
    }
}
//====================================
package TypeInheritance;

public class MyClassTest {
    public static void main(String[] args) {
        
        MyClass mClass = new MyClass();
        
        X xClass = mClass;
        xClass.x();

        Y yClass = mClass;
        yClass.y();

        MyInterface iClass = mClass;
        iClass.myMethod();
        iClass.x();
        iClass.y();
    }
}
```

## 인터페이스 구현과 클래스 상속 함께 쓰기

```java
package UseInterface.InterfaceAndClassExtends;

import java.util.ArrayList;

public class Shelf {
    protected ArrayList<String> shelf;
    
    public Shelf(){
        //디폴트 생성자. Shelf 클래스를 생성하면 ArrayList도 생성됨
        shelf = new ArrayList<String>();
    }
    
    public ArrayList<String> getShelf(){
        return shelf;
    }
    
    public int getCount(){
        return shelf.size();
    }
}
//===============================================
package UseInterface.InterfaceAndClassExtends;

public interface Queue {
    void enQueue(String title);
    String deQueue();
    int getSize();
}
//===============================================
package UseInterface.InterfaceAndClassExtends;

public class BookShelf extends Shelf implements Queue{

    @Override
    public void enQueue(String title) {
        shelf.add(title);
    }

    @Override
    public String deQueue() {
        return shelf.remove(0);
    }

    @Override
    public int getSize() {
        return getCount();
    }
}
//===============================================
package UseInterface.InterfaceAndClassExtends;

public class BookShelfTest {
    public static void main(String[] args) {
        Queue shelfQueue = new BookShelf();
        shelfQueue.enQueue("태백산맥 1");
        shelfQueue.enQueue("태백산맥 2");
        shelfQueue.enQueue("태백산맥 3");

        System.out.println(shelfQueue.deQueue());
        System.out.println(shelfQueue.deQueue());
        System.out.println(shelfQueue.deQueue());
    }
}
```

## 다중상속(자바의 정석)

- TVCR : 클래스 상속과 인터페이스 구현 하는 클래스
- Tv : Tv 클래스
- VCR : VCR과 관련된 클래스
- **IVCR : VCR 관련 인터페이스**

=> TVCR을 구현하기 위해서는 Tv클래스와 VCR클래스를 모두 상속받아서 사용해야 하지만, 자바에서는 다중상속이 이루어지지 않습니다.

=> VCR 관련부분을 인터페이스로 만들고(IVCR), TVCR에서 Tv클래스를 상속받고 IVCR을 구현합니다.

=> VCR을 인스턴스로 만들어 필요한 기능을 수행하여 Tv클래스와 VCR클래스를 함께 사용하는 효과를 얻을 수 있습니다.

```javascript
package UseInterface.JavaStandard;

public class Tv {
    protected boolean power;
    protected int channel;
    protected int volume;

    public void power(){ power = ! power; }
    public void channelUp() { channel++; }
    public void channelDown() { channel--; }
    public void volumeUp() { volume++; }
    public void volumeDown() { volume--; }

}
//====================================================
public class VCR {
    protected int counter; //VCR의 카운터
    public void play(){

    }

    public void stop(){

    }

    public void reset(){
        counter = 0;
    }

    public int getCounter(){
            return counter;
    }

    public void setCounter(int c){
        counter = c;
    }
}
//====================================================
public interface IVCR {
    public void play();
    public void stop();
    public void reset();
    public int getCounter();
    public void setCounter(int c);
}
//====================================================
package UseInterface.JavaStandard;

/**
 * 클래스 상속, 인터페이스 구현
 */
public class TVCR extends Tv implements IVCR{

    VCR vcr = new VCR();

    @Override
    public void play() {
        vcr.play();
    }

    @Override
    public void stop() {
        vcr.stop();
    }

    @Override
    public void reset() {
        vcr.reset();
    }

    @Override
    public int getCounter() {
        return vcr.getCounter();
    }

    @Override
    public void setCounter(int c) {
        vcr.setCounter(c);
    }
}
```

