# 7-1. 배열 - 배열 선언과 초기화, 객체 배열 사용, 배열 복사

## 배열

- 동일한 자료형의 변수를 순차적으로 관리하는 구조

### 배열의 선언과 초기화

```java
/*
선언 
자료형[] 배열이름 = new 자료형[개수];
자료형 배열이름[] = new 자료형[개수];
*/

//int형 요소가 10개인 배열 선언
int[] studentIds = new int[10]; 

//배열 초기화
int[] studentIds = new int[] {101, 102, 103};
int[] studentIds = {101, 102, 103};

int[] studentsIds; //배열자료형선언
studentsIds = new int[]{101,102,103}; //new int[]를 생략할 수 없음
```

### 배열사용시 주의점

- 배열의 순서는 0부터 시작합니다.
- 배열의 끝을 넘어가서 호출하지 않도록 주의합니다.(예외발생)
- 배열에서 초기화 되지 않은 요소의 값은 0으로 자동 초기화 됩니다.

### 문자 저장 배열 만들기

```java
public class CharArray {

    public static void main(String[] args) {
        char[] alphabets = new char[26];
        char ch = 'A';

        for (int i = 0; i < alphabets.length; i++, ch++) {
            alphabets[i] = ch; //아스키 값으로 각 요소 저장
        }

        for (int i = 0; i < alphabets.length; i++) {
            System.out.println(alphabets[i] + "," + (int)alphabets[i]);       
        }
    }
}

/*
결과
A,65
B,66
C,67
D,68
...
*/
```

### 객체 배열 사용하기

- 참조 자료형으로 선언하는 객체 배열사용

```java
package array.book;

/**
 * Book 객체를 만들고 Book 객체의 배열을 생성
 */
public class Book {
    private String bookName;
    private String author;

    public Book() {}

    //책 이름과 저자 이름을 매개변수로 받는 생성자
    public Book(String bookName, String author){
        this.bookName = bookName;
        this.author = author;
    }

    public String getBookName() {
        return bookName;
    }

    public void setBookName(String bookName) {
        this.bookName = bookName;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    //책 정보를 출력해 주는 메소드
    public void showBookInfo(){
        System.out.println(bookName + "," + author);
    }
}

public class BookArray {

    public static void main(String[] args) {
        Book[] library = new Book[5];

        library[0] = new Book("태백산맥", "조정래");
        library[1] = new Book("데미안", "헤르만 헤세");
        library[2] = new Book("어떻게 살 것인가", "유시민");
        library[3] = new Book("토지", "박경리");
        library[4] = new Book("어린왕자", "생텍쥐페리");

        for (int i = 0; i < library.length; i++) {
                library[i].showBookInfo();
        }

        for (int i = 0; i < library.length; i++) {
            System.out.println(library[i]);
        }


    }

}
/*
태백산맥,조정래
데미안,헤르만 헤세
어떻게 살 것인가,유시민
토지,박경리
어린왕자,생텍쥐페리
//Book 인스턴스를 저장한 메모리 공간 주소
array.book.Book@35f983a6
array.book.Book@7f690630
array.book.Book@edf4efb
array.book.Book@2f7a2457
array.book.Book@566776ad
*/
```

## 나 혼자 코딩

```java
package SelfCoding.student;

/**
 * 학생 객체를 만들고 객체 배열 해보기
 */
public class Student {

    private int studentID;
    private String name;

    public Student(int studentID, String name){
        this.studentID = studentID;
        this.name = name;
    }
    public int getStudentID() {
        return studentID;
    }

    public void setStudentID(int studentID) {
        this.studentID = studentID;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String showStudentInfo(){
        return studentID + "," + name;
    }

}

package SelfCoding.student;

public class StudentArray {

    public static void main(String[] args) {
        Student[] students = new Student[3];

        students[0] = new Student(1001, "James");
        students[1] = new Student(1002, "Tomas");
        students[2] = new Student(1003, "Edward");

        for (int i = 0; i < students.length; i++) {
            System.out.println(students[i].showStudentInfo());
        }
    }

}

/*
1001,James
1002,Tomas
1003,Edward
*/
```

## 배열 복사하기

- 배열을 복사하는 두가지 방법
  - 기존 배열과 배열 길이가 같거나 더 긴 배열을 만들고 for문을 사용하여 각 요소 값을 반복해서 복사
  - System.arraycopy(src, srcPos, dest, destPos, length)
    - src : 복사할 배열 이름
    - srcPos : 복사할 배열의 첫 번째 위치
    - dest : 복사해서 붙여 넣을 대상 배열 이름
    - destPos : 복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치
    - length : src에서 dest로 자료를 복사할 요소 개수
- 주의 사항 : 복사할 대상 배열(array2)의 전체 길이가 복사할 요소 개수보다 작다면 오류를 발생합니다.
  - 만약 5개를 array2의 1위치부터 복사를 시작했다면 에러 발생

```java
public class ArrayCopy {

    public static void main(String[] args) {
        int[] array1 = {10, 20, 30, 40, 50};
        int[] array2 = {1, 2, 3, 4, 5};

        System.arraycopy(array1, 0, array2, 1, 4);

        for (int i = 0; i < array2.length; i++) {
            System.out.println(array2[i]);
        }
    }
}

/*
1
10
20
30
40
*/
```

### 객체 배열 복사하기

```java
public class ObjectCopy {

    public static void main(String[] args) {
        Book[] bookArray1 = new Book[3];
        Book[] bookArray2 = new Book[3];

        bookArray1[0] = new Book("태백산맥", "조정래");
        bookArray1[1] = new Book("데미안", "헤르만 헤세");
        bookArray1[2] = new Book("어떻게 살 것인가", "유시민");

        System.arraycopy(bookArray1, 0, bookArray2, 0, 3);

        for (int i = 0; i < bookArray2.length; i++) {
            bookArray2[i].showBookInfo();
        }
   }
}
```

### 얕은 복사

- bookArray2를 변경하지 않았는데, 요소가 bookArray1의 변경사항을 그대로 받아들여 변경

  - 이유

    - 배열의 요소에 저장된 값은 인스턴스 그 자체가 아닌, 인스턴스의 주소 값이기 때문
    - 따라서 객체 배열을 복사할 때 인스턴스를 생성하는 게 아니라 기존 인스턴스의 주소 값만 복사하는 형태
    - 결국 두 배열의 서로 다른 요소가 같은 인스턴스를 가리키고 있는 상황 

    => 그러므로 한쪽이 변경되면 다른 한쪽이 영향을 받을 수 있다.

```java
/**
 * 얕은 복사
 */
public class ShallowCopy {
    public static void main(String[] args) {
        Book[] bookArray1 = new Book[3];
        Book[] bookArray2 = new Book[3];

        bookArray1[0] = new Book("태백산맥", "조정래");
        bookArray1[1] = new Book("데미안", "헤르만 헤세");
        bookArray1[2] = new Book("어떻게 살 것인가", "유시민");

        System.arraycopy(bookArray1, 0, bookArray2, 0, 3);

        for (int i = 0; i < bookArray2.length; i++) {
            bookArray2[i].showBookInfo();
        }

        System.out.println("=== bookArray1 ===");
        bookArray1[0].setBookName("나목");
        bookArray1[0].setAuthor("박완서");
        for (int i = 0; i < bookArray1.length; i++) {
            bookArray1[i].showBookInfo();
        }

        System.out.println("=== bookArray2 ===");
        for (int i = 0; i < bookArray2.length; i++) {
            bookArray2[i].showBookInfo();
        }
    }
}
/*
태백산맥,조정래
데미안,헤르만 헤세
어떻게 살 것인가,유시민
=== bookArray1 ===
나목,박완서
데미안,헤르만 헤세
어떻게 살 것인가,유시민
=== bookArray2 ===
나목,박완서
데미안,헤르만 헤세
어떻게 살 것인가,유시민
*/
```

### 깊은 복사

- 인스턴스를 따로 관리하고 싶다면 직접 인스턴스를 만들어서 그 값을 복사 => 깊은복사
  - 복사한 배열 요소는 기존 배열 요소와 서로 다른 인스턴스를 가리키므로 기존 배열의 요소 값이 변경되어도 영향을 받지 않음

```java
/**
 * 깊은 복사
 */
public class DeepCopy {
    public static void main(String[] args) {

        Book[] bookArray1 = new Book[3];
        Book[] bookArray2 = new Book[3];

        bookArray1[0] = new Book("태백산맥", "조정래");
        bookArray1[1] = new Book("데미안", "헤르만 헤세");
        bookArray1[2] = new Book("어떻게 살 것인가", "유시민");

        //디폴트 생성자로 배열 bookArray2 인스턴스 생성
        bookArray2[0] = new Book();
        bookArray2[1] = new Book();
        bookArray2[2] = new Book();

        //bookArray1 배열 요소를 새로 생성한 bookArray2 배열 인스턴스에 복사
        for (int i = 0; i < bookArray1.length; i++) {
            bookArray2[i].setBookName(bookArray1[i].getBookName());
            bookArray2[i].setAuthor(bookArray1[i].getAuthor());
        }

        for (int i = 0; i < bookArray2.length; i++) {
            bookArray2[i].showBookInfo();
        }

        System.out.println("=== bookArray1 ===");
        bookArray1[0].setBookName("나목");
        bookArray1[0].setAuthor("박완서");
        for (int i = 0; i < bookArray1.length; i++) {
            bookArray1[i].showBookInfo();
        }

        System.out.println("=== bookArray2 ===");
        for (int i = 0; i < bookArray2.length; i++) {
            bookArray2[i].showBookInfo();
        }
    }
}

/*
태백산맥,조정래
데미안,헤르만 헤세
어떻게 살 것인가,유시민
=== bookArray1 ===
나목,박완서
데미안,헤르만 헤세
어떻게 살 것인가,유시민
=== bookArray2 ===
태백산맥,조정래
데미안,헤르만 헤세
어떻게 살 것인가,유시민
*/
```

### 향상된 for문과 배열

```java
public class EnhancedForLoop {

    public static void main(String[] args) {
        String[] strArray = {"Java", "Android", "C", "JavaScript", "Python"};

        for(String lang : strArray){
            System.out.println(lang);
        }
    }
}

/*
Java
Android
C
JavaScript
Python
*/
```

