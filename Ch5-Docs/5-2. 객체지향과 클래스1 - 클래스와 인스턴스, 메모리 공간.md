# 5-2. 객체지향과 클래스1 - 클래스와 인스턴스, 메모리 공간

## 클래스와 인스턴스

- 객체 클래스와 실행 클래스를 분리

  - 실행 클래스에서 객체의 인스턴스를 생성
  - 인스턴스 : 실제로 사용할 수 있도록 메모리공간에 할당한 클래스의 객체

  ```java
  클래스형 변수 이름 = new 생성자;
  Student student  = new Student();
  ```

```java
//객체 클래스
package Student;

public class Student {

    int studentID;
    String studentName;
    int grade;
    String address;

    public String getStudentName(){
        return studentName;
    }
}

//실행 클래스
package Student;

public class StudentTest {
    public static void main(String[] args) {
        Student student = new Student();
        student.studentName = "walter";
				
      	//객체의 멤버변수 값 출력
        System.out.println(student.studentName);
      	//객체의 메소드 실행결과 출력
        System.out.println(student.getStudentName());
    }
}

/*결과
walter
walter
*/
```

### 인스턴스와 참조변수

- 인스턴스 : 클래스가 메모리 공간에 생성된 상태

- 참조 변수 : 인스턴스의 멤버 변수와 메소드를 참조할 수 있는 변수
  - 도트(.)연산자 이용

```java
student.studentName = "walter"; //멤버변수 참조
sutdent.getStudentName(); //메소드 참조
```

## 인스턴스와 힙 메모리

- 힙 메모리(heap memory) : 인스턴스가 저장된 메모리
  - 동적 메모리 공간. 객체가 생성될 때 사용하는 공간
  - 가비지 컬렉터에 의해 자동으로 메모리 해제

### JVM 메모리공간(이미지 출처 : https://jeong-pro.tistory.com/148)

![image-20210306152028393](/Users/wonik/Library/Application Support/typora-user-images/image-20210306152028393.png)

- Class Loader

  - .javaf를 컴파일하여 .class파일로 변환 후 클래스 파일들을 묶어서 JVM에 적재

- Execution Engine

  - Class Loader에 의해 메모리에 적재된 클래스들을 기계어로 변경해 명령어 단위로 실행하는 역할
  - java에서 JIT(Just In Time) 컴파일러 이용 - 인터프리터와 비교
    - JIT : 적절한 시간에 전체 바이트 코드를 네이티브 코드로 변환하여 Excecution Engine이 네이티브로 컴파일된 코드를 실행하는 것으로 성능을 높임

- **Garbage Collector**

  - Heap 메모리 영역에 있는 객체 중 참조되지 않는 객체들을 자동으로 해제하여 메모리의 효율성을 높여줌

- RunTime Data Area

  - JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
  - **Method Area(메소드 영역)** 
    - 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보 같은 필드 정보와 메소드의 이름, 리턴 타입, 파라미터, 접근 제어자, <u>static 변수</u>, final 클래스 등 <u>클래스에 연관된 것들이 생성되는 영역</u>
  - **Heap Area(힙 영역)**
    - <u>new 키워드로 생성된 객체와 배열이 생성되는 영역</u> =>인스턴스 변수 생성
    - <u>Garbage Collector가 참조되지 않는 객체를 해제할 수 있는 영역</u>
  - **Stack Area(스택 영역)**
    - <u>지역 변수</u>, 파라미터, 리턴 값, 연산에 사용되는 임시 값 등이 생성되는 영역
    - Student student = new Student();
      - Student student : 스택 영역에 생성
      - new Student()로 생성한 인스턴스 student : 힙 영역에 생성

  ```java
  //Stack 설명 - 메소드가 호출되면 먼저 들어와 있는 메소드는 정지됨
  class StackTest{
    public static void main(String[] args){
      firstMethod();
    }
    
    static void firstMethod(){
      secondMethod();
    }
    
    static void secondMethod(){
      System.out.println("secondMethod()");
    }
  }
  
  /*
  1 : main => 프로그램 시작
  2 : firstMethod - main
  3 : secondMethod - firstMethod - main 
  4 : println - secondMethod - firstMethod - main
  5 : secondMethod - firstMethod - main
  6 : firstMethod - main
  7 : main
  */
  ```

  - PC Register(PC 레지스터)
    - Thread가 생성될 때 마다 생성되는 영역
    - 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하는 영역
    - 쓰레드를 돌아가면서 수행할 수 있도록 함
  - Native Method Stack
    - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
    - 보통 c/c++등의 코드를 수행하기 위한 스택

  ### 참조 변수와 참조 값

  - 참조 변수 : 힙 메모리에 생성된 인스턴스를 가리킴
    - hashcode(주소)가 다른 것을 확인 할 수 있음

  ```java
  package Student;
  
  public class StudentTest2 {
  
      public static void main(String[] args) {
          Student student1 = new Student();
          student1.studentName = "walter";
  
          Student student2 = new Student();
          student2.studentName = "walter";
  
          System.out.println(student1);
          System.out.println(student2);
          
      }
  
  }
  /*
  결과
  Student.Student@56cbfb61
  Student.Student@1134affc
  */
  ```

  ### 용어정리

  | 용어      | 설명                                       |
  | --------- | ------------------------------------------ |
  | 객체      | 객체 지향 프로그램의 대상. 생성된 인스턴스 |
  | 클래스    | 객체를 코드로 만든 것                      |
  | 인스턴스  | 클래스가 메모리에 생성된 상태              |
  | 멤버 변수 | 클래스의 속성                              |
  | 메소드    | 클래스의 기능                              |
  | 참조 변수 | 메모리에 생성된 인스턴스를 가리키는 변수   |
  | 참조 값   | 생성된 인스턴스의 메모리 주소 값           |

  

  ### 나혼자 코딩

  ```java
  package SelfCoding;
  
  /**
   * 나 혼자 코딩
   * 나이가 40살, 이름이 James라는 남자가 있습니다. 이 남자는 결혼을 했고, 자식이 셋 있습니다.
   * 나이, 이름, 결혼 여부, 자녀 수를 리턴하는 함수
   */
  public class Person {
      int age;
      String name;
      boolean isMarried; //결혼여부
      int children; //자녀의 수
  
       public String toString(){
          return "나이 : " + age + " / "
                  + "이름 : " + name + " / "
                  + "결혼여부 : " + isMarried + " / "
                  + "자녀의 수 : " + children;
      }
  }
  
  class PersonTest{
      public static void main(String[] args) {
          Person person = new Person();
          person.age = 40;
          person.name = "James";
          person.isMarried = true;
          person.children = 3;
  
          System.out.println(person.toString());
      }
  }
  
  
  /*
  나이 : 40 / 이름 : James / 결혼여부 : true / 자녀의 수 : 3
  */
  ```

  ```java
  package SelfCoding;
  
  /**
   * 쇼핑몰에 주문이 들어왔습니다.
   * 주문 내용에 대한 클래스를 만들고 주문 내용을 인스턴스로 생성 후 주문내용을 그대로 출력
   */
  class ShoppingInfo{
      long orderNumber; //주문 번호
      String orderID; //주문자 아이디
      String orderDate; //주문날짜
      String orderName; //주문자 이름
      String orderProductNumber; //주문 상품 번호
      String address; //배송 주소
  
      public String toString(){
          return "주문 번호 : " + orderNumber + "\n"
                  + "주문자 아이디 : " + orderID + "\n"
                  + "주문 날짜 : " + orderDate + "\n"
                  + "주문자 이름 : " + orderName + "\n"
                  + "주문 상품 번호 : " + orderProductNumber + "\n"
                  + "배송주소 : " + address;
  
      }
  }
  
  public class Shopping {
      public static void main(String[] args) {
          ShoppingInfo shoppingInfo = new ShoppingInfo();
  
          //int로 표현하기 너무 큰 숫자라서 long 타입으로 설정
          shoppingInfo.orderNumber = 201803120001L;
          shoppingInfo.orderID = "abc123";
          shoppingInfo.orderDate = "2018년 3월 12일";
          shoppingInfo.orderName = "홍길순";
          shoppingInfo.orderProductNumber = "PD0345-12";
          shoppingInfo.address = "서울시 영등포구 여의도동 20번지";
  
          System.out.println(shoppingInfo.toString());
      }
  }
  ```

  

