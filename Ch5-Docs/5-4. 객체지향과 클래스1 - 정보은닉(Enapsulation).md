# 5-4. 객체지향과 클래스1 - 정보은닉(Enapsulation)

- 예약어를 이용해 클래스 내부의 변수나 메소드, 생성자에 대한 접근을 제어할 수 있음

## 접근 제어자(access modifier)

사용이유 : 외부로부터 데이터를 보호하기 위해서, 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해서

- private - 같은 클래스 내에서만 접근가능
- default(package) - 같은 패키지 내에서만 접근가능
- protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능
- public - 접근 제한이 전혀 없음
- 넓은 범위 순 -> public > protected > default(package) > private

### 생성자의 접근제어자

보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만 다르게 지정할 수도 있음

- private생성자를 지정하면 외부에서는 생성자를 접근할 수 없어 인스턴의 생성이 불가함
  - 인스턴스를 생성해서 반환해주는 public 메서드를 제공하여 외부에서 인스턴스를 사용하도록 지원해줘야 함(public static 이용)
- 내부에서는 인스턴스를 생성하여 사용
- 아래와 같은 방법으로 인스턴스 생성의 개수를 제한할 수 있음

```java
class Singleton{
	private static Singleton s = new Singleton(); //getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static이어야 함
  
  private Singleton(){}
  
  //private 생성자이므로 인스턴스를 생성하지 않고 사용할 수 있도록 public static으로 지정
  public static Singleton getInstance(){
    return s;
  }
}
```

## get(), set() 메소드

- private 선언한 멤버변수를 외부에서 접근하는 방법

```java
public class Student{
  int studentID;
  private String studentName;
  int grade;
  String address;
  
  public String getStudentName(){
    return studentName; //private 변수인 studentNamedp 접근해 값을 가져오는 public get() 메소드
  }
  
  public void setStudentName(String studentName){
    this.studentName = studentName; //private 변수인 studentName 접근해 값을 지정하는 public set()메소드
  }
}
```

## 정보 은닉

- 변수에 접근하는 것을 막아 잘 못된 정보를 설정하지 못하도록 함

```java
//public으로 멤버변수에 접근할 수 있는 클래스
public class MyDate{
  public int day;
  public int month;
  public int year;
}
//멤버변수를 마음대로 수정 => 잘못된 정보 입력 가능
public class MyDateTest{
  public static void main(String[] args){
    MyDate date = new MyDate();
    date.month = 2;
    date.day = 31;
    date.year = 2021;
  }
}
```

- 잘 못된 정보를 넣지 못하도록 변경 => 정보은닉(외부에서 접근 방지)

```java
//멤버변수를 private으로 변경. 멤버변수를 수정할 수 있는 setter 메소드를 public으로 제공
//*윤년은 고려하지 않음
public class MyDate{
  private int day;
  private int month;
  private int year;
  
  public void setDay(int day){
    if(month == 2){
      if(day < 1 || day > 28){
        System.out.println("오류입니다.");
      } else {
        this.day = day;
      }
    }
  }
}
```

```java
package Encapulation;

/**
 * 자바의 정석
 * 접근 제어자를 이용하여 외부에서 직접 접근하지 못하도록 함
 */

class Time {

    //private으로 외부 접근을 막음
    private int hour;
    private int minute;
    private int second;

    Time(int hour, int minute, int second) {
        setHour(hour);
        setMinute(minute);
        setSecond(second);
    }

    //Getter, Setter로 외부접근을 허용
    public int getHour() {
        return hour;
    }
    public void setHour(int hour) {
        if(hour < 0 || hour > 23) return;
        this.hour = hour;
    }

    public int getMinute() {
        return minute;
    }
    public void setMinute(int minute) {
        if(minute < 0 || minute > 59) return;
        this.minute = minute;
    }

    public int getSecond() {
        return second;
    }
    public void setSecond(int second) {
        if(second < 0 || second > 59) return;
        this.second = second;
    }

    public String toString(){
        return hour + ":" + minute + ":" + second;
    }
}

public class AccessModifier {
    public static void main(String[] args) {
        Time t = new Time(12, 35, 30);
        System.out.println(t);
        //t.hour = 13; //멤버변수에 직접 접근이 불가함
        t.setHour(t.getHour()+1); //현재보다 한시간 후로 변경
        System.out.println(t);
    }
}
/*
결과
12:35:30
13:35:30
*/
```

### 나 혼자 코딩

```java
/**
 * test 패키지를 새로 만들고 Student와 StudentTest 분리
 */
package SelfCoding.test;

public class Student {
    int studentID;
//    private String studentName;
    public String studentName;
    int grade;
    String address;

    public String getStudentName() {
        return studentName;
    }

    public void setStudentName(String studentName) {
        this.studentName = studentName;
    }
}


package SelfCoding.test.test;

import SelfCoding.test.Student;

/**
 * 코드의 중복을 막기위해 test.test 패키지로 만듦
 *
 * Student 클래스의 접근제어자를 변경하여 기존에 있던 오류를 수정
 * private으로 접근 불가능한 studentName에 접근하기 위해 필요한것은?
 */
public class StudentTest {
    public static void main(String[] args) {
        Student student = new Student();

        //private에 접근 => Student의 studentName을 public으로 변
        student.studentName = "walter";
        student.setStudentName("walter");

        System.out.println(student.getStudentName());
    }
}

```

### 제어자의 조합

1. 메서드에 static과 abstract를 함께 사용할 수 없음
   - static 메소드는 몸통이 있는 메소드에만 사용할 수 있기 때문
2. 클래스에 abstract와 final을 동시에 사용할 수 없음
   - 클래스에 사용되는 final은 클래스를 확장 할 수 없음 => abstract는 확장을 위한 예약어이므로 상반됨
3. abstracts는 private일 수 없음 :  abstract는 확장을 위한 예약어이므로 상반됨
4. 메소드에 private과 final을 같이 사용할 필요는 없음
   - private인 메소드는 오버라딩 될 수 없기 때문에 둘중 하나만 사용해도 됨

