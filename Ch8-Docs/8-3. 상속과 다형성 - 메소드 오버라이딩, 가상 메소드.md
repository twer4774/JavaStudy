# 8-3. 상속과 다형성 - 메소드 오버라이딩, 가상 메소드

## 상위 클래스 메소드 재정의하기

- 오버라이딩의 조건(자바의 정석)
  - 자손클래스에서 오버라이딩 하는 메소드는 조상 클래스의 메소드와
    - 이름이 같아야 합니다.
    - 매개변수가 같아야 합니다.
    - 반환타입이 같아야 합니다.
  - 조상 클래스의 메소드를 자손 클래스에서 오버라이딩 할 때
    - 접근 제어자를 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없습니다. => 조상클래스가 package라면 자손 클래스의 메소드는 private이나 package가 되어야 합니다.
    - 예외는 조상 클래스의 메소드보다 많이 선언할 수 없습니다.
    - 인스턴스 메소드를 static메소드 또는 그 반대로 변ㄱㅇ할 수 없습니다.

- VIP 고객에게 제공하는 할인율과 세일 가격을 어떻게 적용할지 구현필요 => 메소드 오버라이딩 필요

> VIP 고객의 혜택 => 정가에서 10% 할인

- **오버라이딩을 하려면 반환형, 메소드 이름, 매개변수, 매개변수 자료형이 반드시 같아야 합니다.**

### VIP 고객 클래스의 제품 가격 계산 메소드 재정의하기(오버라이딩하기)

```java
//VIP Customer
//메소드 오버라이딩
    @Override
    public int calcPrice(int price) {
        bonusPoint += price * bonusRatio; //포인트 적립
        return price - (int)(price * saleRatio); //할인된 가격을 계산하여 반환
    }
```

- @Override 어노테이션 : '이 메소드는 재정의된 메소드입니다'를 컴파일러에게 명확히 알려주는 역할을 합니다.

  - 어노테이션 : 컴파일러에게 특정 정보를 제공해주는 역할

  - 표준 어노테이션

  | 어노테이션           | 설명                                                      |
  | -------------------- | --------------------------------------------------------- |
  | @Override            | 재정의된 메소드라는 정보 제공                             |
  | @FunctionalInterface | 함수형 인터페이스라는 정보 제공                           |
  | @Deprecated          | 이후 버전에서 사용되지 않을 수 있는 변수, 메소드에 사용됨 |
  | @SuppressWarnings    | 특정 경고가 나타나지 않도록 함                            |

```java
//OverridingTest
public static void main(String[] args) {
        Customer customerLee = new Customer(10010, "이순신");
        customerLee.bonusPoint = 1000;

        VIPCustomer customerKim = new VIPCustomer(10020, "김유신", 12345);
        customerKim.bonusPoint = 10000;

        int price = 10000;
        System.out.println(customerLee.getCustomerName() + "님이 지불해야 하는 금액은 " + customerLee.calcPrice(price) + "원입니다.");
        System.out.println(customerKim.getCustomerName() + "님이 지불해야 하는 금액은 " + customerKim.calcPrice(price) + "원입니다.");
    }

/*
이순신님이 지불해야 하는 금액은 10000원입니다.
김유신님이 지불해야 하는 금액은 9000원입니다.
*/
```

## 묵시적 클래스 형 변환과 메소드 재정의

```java
Customer vc = new VIPCustomer(10030, "나몰라", 2000);
vc.calcPrice(1000);
```

- 위와 같이 Customer, VIPCustomer 두 상속관계의 클래스에서 모두 calcPrice 가지고 있다면?
  - 같은 이름의 메소드가 존재할 때는 호출되는 메소드의 인스턴스에 따라 결정됩니다. 
    => 여기에서는 VIPCustomer가 인스턴스를 생성하기 때문에 VIPCustomer의 재정의된 메소드가 호출
    => 인스턴스의 메소드가 호출 되는 기술 : 가상메소드(virtual method)

## 가상 메소드(virtual method)

```java
public class TestA {

    public static void main(String[] args) {
        TestA a1 = new TestA();
        a1.aaa();

        TestA a2 = new TestA();
        a2.aaa();
    }

    private void aaa() {
        System.out.println("aaa() 출력");
    }
}
```

- 메모리 공간의 할당
  - 메소드 영역 : aaa() 메소드 영역 할당
  - 힙영역 : new TestA()로 생성된 인스턴스  a1, a2 할당
  - 스택 영역 : 지역 변수 할당
    -  a1, a2 : a1.aaa() 호출시 지역변수로 할당됨
    -  args : main함수의 지역변수

### 가상 메소드의 원리

- 가상 메소드 테이블을 이용해 각 메소드 이름과 실제 메모리 주소가 짝을 이루도록 합니다.

  - 어떤 메소드가 호출되면 이 테이블에서 주소 값을 찾아서 해당 메소드의 명령을 수행합니다.

  ```java
  public class OverridingTest {
      public static void main(String[] args) {
          int price = 10000;
  
          Customer customerLee = new Customer(10010, "이순신");
          System.out.println(customerLee.getCustomerName() + " 님이 지불해야 하는 금액은" + customerLee.calcPrice(price));
  
          VIPCustomer customerKim = new VIPCustomer(10020, "김유신", 1234);
          System.out.println(customerKim.getCustomerName() + " 님이 지불해야 하는 금액은" + customerKim.calcPrice(price));
  
          Customer vc = new VIPCustomer(10030, "나몰라", 2000);
          System.out.println(vc.getCustomerName() + " 님이 지불해야 하는 금액은" + vc.calcPrice(price));
      }
  }
  /*
  이순신 님이 지불해야 하는 금액은10000
  김유신 님이 지불해야 하는 금액은9000
  나몰라 님이 지불해야 하는 금액은9000
  */
  ```

  