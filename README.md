# JavaStudy

■ 2021-03-06 (0일차)
 - 매주 토요일 1시 ~ 5시 (총 4시간 진행)
 - 스터디 전까지 최소 1개 챕터 이상 공부하기
 - 발표 및 토론 (2시간 30분) / 코딩 문제 풀기 (1시간 30분)
 - 이해가 잘 되지 않는 부분은 필히 체크하기!


■ 2021-03-13 (1일차)
 - 클래스에 대한 이해
    - 클래스를 사용하는 이유
        - 관리의 효율성을 위해서다.
        - 예를 들면, 사람이란 클래스를 만들 때 편리하다.
          그 이유는 클래스 안에 사람에 대한 데이터(이름, 나이, 주소 등)를 지정하고, 
          행위에 대한 메소드를 만들면, 하나의 클래스를 편하게 다룰 수 있기 때문이다.

          ■ 주의할 점, 클래스와 객체의 의미는 다르다.
            - 클래스는 설계도 라고 이해하면 되고, 객체는 설계도로 구현한 모든 대상을 의미한다.
              Ex) 클래스를 만들어 놓고 쓰지 않으면, 설계도의 존재 이유가 없다.
                  우리가 클래스(설계도)를 이용하여, 무엇을 만든다면, 그것이 바로 객체란 개념이다.
                  그 객체가 바로 클래스의 인스턴스다.
                  Ex) public class A { int a }
                  순서 : 클래스 생성 -> 객체 생성 -> 사용
          
    - Top level 클래스는 public으로 선언하고 반드시 java 파일명과 같아야 한다.
      Ex) public class Test {} == Test.java

    - Main 메소드는 하나의 프로젝트에서 여러 개 존재할 수 없으며, 무조건 하나다.
      그리고 프로그램은 Main에서 시작하고, Main에서 끝난다.
      즉, Main 안에서 여러 메소드를 호출하고, 호출한 메소드는 또 다른 메소드를 호출할 수도 있다.
      결국에는 돌고 돌아, 다시 Main으로 돌아오게 되어 있다.

 - 스태틱(static) 과 인스턴스(instance) 의 차이
    - 인스턴스 메소드와 변수는 반드시 new 선언을 해야 사용 가능하다.
      이유 : 멤버 변수 즉, 클래스 내부에서 선언한 변수들은 new 선언을 하지 않으면,
             Heap 메모리 영역에 할당이 되지 않기 때문에 사용할 수가 없다.
             따라서, 사용하기 위해서는 힙 메모리 영역에 할당을 해야 한다.
             Ex) public class Test {
                 int t;
             }
                public static void Main(String[] args) {
                    Test t; <- new 선언을 하지 않았기 때문에, Heap 메모리 영역에 할당 X
                    따라서, t.t <- 는 사용 불가능이다.

                    t = new Test() <- new 선언으로 Heap 메모리 영역에 할당 O
                    따라서, t.t <- 는 사용 가능하다.
                }

      단점 : 과도한 사용은 메모리를 많이 잡아 먹으며, 치명적인 오류로 이어질 수 있다.
             Ex) 어떤 한 프로그램을 실행중인데 메모리 점유율이 타 실행중인 프로그램에 비해
                 훨씬 높으면, 다른 프로그램을 사용할 수 없게 되는 상황에 이르기도 한다.

    - static은 어떤 인스턴스든 접근하여 사용 가능하지만, 남발하면 시스템 성능 저하를 일으킨다.
      이유 : static은 클래스가 로딩되는 순간 메소드 영역(Method Area)에 처음으로 
             생성되어 메모리를 할당한다. 
             그 메모리는 파일이 종료되기 전까지 남아있기 때문에, 중간에 제거를 할 수가 없다. 따라서, 무분별한 사용은 하지 않는 게 좋다.
             TIP) 절대 바뀌지 않는 변수를 설정해야 할 때, static 변수가 제격이다.
                 public final static int MAX = 100;
                 여기서 final은 변하지 않는 값 즉, 상수를 의미한다.
                 참고로, 상수는 모두 대문자로 선언해야 한다.

      장점 : 손쉽게 사용 가능하다. (클래스명.static메소드 or 변수)
             객체를 생성하는 게 아니기 때문에 더 빠르다.
      단점 : 고정 메모리가 할당되기 때문에 많이 사용하면, 메모리 관리 측면에서 효율성이 떨어진다.

 - 생성자와 this에 대한 이해
    - 생성자는 초기화를 위해 사용한다.
    - new() 에서 () 부분이 생성자를 의미하며, 생성자를 사용하지 않고 코드를 구현한다면,
      더 많은 코드를 짜야 하기 때문에, 효율적인 측면에서 생성자를 사용한다.
      사용법) 
      public class Person {
          String name;
          int age;

          public static void Main(String[] args) {
              생성자가 없다면?
              Person p = new Person();
              p.name = "제임스";
              p.age = 20;
              
              생성자가 있다면?
              Person p = new Person("제임스", 20);
              
              ! 이게 바로 생성자를 사용하는 이유이다.
          }
      }
    - this는 내장변수라고 부르며, 인스턴스의 자기 자신을 의미한다.
    - this를 사용하는 이유는, 인스턴스 변수임을 명확히 하기 위함이다.
      Ex) public class Cafe {
            String name;
            String menu;
            int price;
            
            public Cafe(String name, String menu) {
                this.name = name; 
                this.menu = menu;

                여기서 this.name은 Cafe 클래스 내부에 선언된 String name을 의미하며,
                name은 생성자에서 받아 온 파라미터(매개변수)를 의미한다.
                따라서, this.name과 name은 절대 같은 값이 아니다.
            }
      }

 - 접근제어자의 이해
    - private, default, protected, public 네 가지 종류로 이루어져 있다.
        - private 은 현재 클래스 내부에서만 사용 가능하다.
        - default 는 리턴타입 앞에 아무 것도 선언하지 않음을 의미하고,
          같은 패키지 안에 있는 다른 파일들이 접근 가능하다.
        - protected 는 같은 패키지와 서브 패키지 즉, 현재 패키지 안의 패키지를 서브 패키지라고
          부르며, 그 범위까지 접근 가능하다.
        - public 은 한 프로젝트 폴더 안에 있는 모든 패키지에 접근 가능하다.

 - Setter 와 Getter의 이해
    - 정보은닉을 위해서 사용한다 (정보은닉에 대해서는 추후 진행할 예정)
    - 인스턴스 변수는 반드시 private으로 선언하며, setter와 getter는 public으로 사용한다.

 - ArrayList 의 사용법 이해
    - 배열 선언
      Ex) int[] i = new int[5]; 또는 int[] i = new int[] {1,2,3,4};
      주의할 점 : int[] i = new int[5] {1,2,3,4,5}; 는 오류다.



■ 2021-03-20 (2일차)


■ 2021-03-27 (3일차)


■ 2021-04-03 (4일차)


■ 2021-04-10 (5일차)


■ 2021-04-17 (6일차)


■ 2021-04-24 (7일차)


■ 2021-05-01 (8일차)