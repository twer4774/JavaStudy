# 11-2. 기본 클래스 - String 클래스

## String을 선언하는 두 가지 방법

```java
String str1 = new String("abc"); //생성자의 매개변수로 문자열 생성
String str2 = "test"; //문자열 상수를 가리키는 방식
```

- 두 방식의 차이
  - new String()을 이용하면 새로운 객체가 생성됩니다. 즉, 새로운 메모리 영역을 할당합니다.
  - 상수를 가리키는 방식을 이용하면, str2가 기존에 만들어져 있던 "test"라는 문자열 상수의 메모리 주소를 가리키게 됩니다.

```java
package String;

public class StringTest {
    public static void main(String[] args) {
        String s1 = new String("abc");
        String s2 = new String("abc");

        System.out.println(s1 == s2); //주소 값이 다르므로 false
        System.out.println(s1.equals(s2)); //문자열 값이 같으므로 true
        
        String s3 = "abc";
        String s4 = "abc";

        System.out.println(s3 == s4); //문자열 abc는 상수 풀에 저장되어 있으므로 가리키는 주소 값이 같음
        System.out.println(s3.equals(s4)); //문자열 값이 같으므로 true

    }

}
```

## String 클래스의 final char[] 변수

- String이 문자열을 저장할 수 있는 이유 : char[]로 배열화 시켜서 사용합니다.
  - 단 final로 설정되어 있으므로, 한 번 생성된 문자열은 변경할 수 없습니다. => StringBuilder의 필요성
- 문자열을 합치는 함수 concat을 이용하면, 문자열이 변경되는 것이 아니라, 새로운 문자열이 생성됩니다.
  - String은 불변이다. 따라서 변경이 아닌 새로이 생성된다.

```java
package String;

public class StringTest2 {
    public static void main(String[] args) {
        String javaStr = new String("java");
        String androidStr = new String("android");
        System.out.println(javaStr);
        System.out.println("처음 문자열 주소 값: " + System.identityHashCode(javaStr));

        //문자열 연결
        javaStr = javaStr.concat(androidStr);

        System.out.println(javaStr);
        System.out.println("연결된 문자열 주소 값 : " + System.identityHashCode(javaStr));
    }

}
/*
java
처음 문자열 주소 값: 1057941451
javaandroid
연결된 문자열 주소 값 : 434091818
*/
```

## StringBuffer와 StringBuilder 클래스 활용하기

- String을 사용하여 문자열을 연결하면 문자열이 계속 생성되므로 메모리가 낭비됩니다.
- StringBuffer와 StringBuilder는 내부적으로 final이 아닌 char[]를 가지고 있습니다.
  - 둘의 차이점 : StringBuffer는 멀티쓰레드 환경에서 동기화를 지원합니다. (둘의 값이 맞도록 보장)
    - 멀티 쓰레드 환경이 아니라면 StringBuilder 사용

```java
package String.StringBuilder;

public class StringBuilderTest {
    public static void main(String[] args) {
        String javaStr = new String("Java");
        System.out.println("javaStr 문자열 주소 : " + System.identityHashCode(javaStr));

        StringBuilder buffer = new StringBuilder(javaStr);
        System.out.println("연산 전 buffer 메모리 주소: " + System.identityHashCode(buffer));
        
        buffer.append(" and");
        buffer.append(" android");
        buffer.append(" programming is fun!!");
        System.out.println("연산 후 buffer 메모리 주소 : " + System.identityHashCode(buffer));

        javaStr = buffer.toString();
        System.out.println(javaStr);
        System.out.println("연결된 javaStr 문자열 주소 : " + System.identityHashCode(javaStr));
    }
}
/* buffer의 메모리 주소는 연산 전,후 동일합니다.
javaStr 문자열 주소 : 1057941451
연산 전 buffer 메모리 주소: 434091818
연산 후 buffer 메모리 주소 : 434091818
Java and android programming is fun!!
연결된 javaStr 문자열 주소 : 398887205
*/
```

