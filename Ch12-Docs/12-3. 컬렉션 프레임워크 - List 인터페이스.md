# 12-3. 컬렉션 프레임워크 - List 인터페이스

## ArrayList

### ArrayList를 활용해 회원 관리 프로그램 구현하기

```java
package Collection.arraylist;

import Collection.Member;

import java.util.ArrayList;

public class MemberArrayList {
    private ArrayList<Member> arrayList;

    public MemberArrayList() {
        arrayList = new ArrayList<Member>();
    }

    public void addMember(Member member) {
        arrayList.add(member);
    }

    public boolean removeMember(int memberId){
        for (int i = 0; i < arrayList.size(); i++) {
            Member member = arrayList.get(i);
            int tempId = member.getMemberId();
            //회원 아이디가 매개변수와 일치하면
            if (tempId == memberId) {
                arrayList.remove(i); //해당 회원 삭제
                return true;
            }
        }
        System.out.println(memberId + "가 존재하지 않습니다.");
        return false;
    }

    public void showAllMember(){
        for (Member member : arrayList) {
            System.out.println(member);
        }
        System.out.println();
    }
}
//================================================================
package Collection.arraylist;

import Collection.Member;

public class MemberArrayListTest {
    public static void main(String[] args) {
        MemberArrayList memberArrayList = new MemberArrayList();

        Member memberLee = new Member(1001, "이지원");
        Member memberSon = new Member(1002, "손민국");
        Member memberPark = new Member(1003, "박서훤");
        Member memberHong = new Member(1004, "홍길동");

        memberArrayList.addMember(memberLee);
        memberArrayList.addMember(memberSon);
        memberArrayList.addMember(memberPark);
        memberArrayList.addMember(memberHong);

        memberArrayList.showAllMember();

        //길동 삭제
        memberArrayList.removeMember(memberHong.getMemberId());
        memberArrayList.showAllMember();
    }

}
/*
이지원 회원님의 아이디는 1001
손민국 회원님의 아이디는 1002
박서훤 회원님의 아이디는 1003
홍길동 회원님의 아이디는 1004

이지원 회원님의 아이디는 1001
손민국 회원님의 아이디는 1002
박서훤 회원님의 아이디는 1003
*/
```

## 나 혼자 코딩

- 맨뒤가 아닌 특정위치에 추가하는 메소드

```java
public void insertMember(Member member, int index){
  if(index < 0 || index > arrayList.size()+1){
    System.out.println("배열의 범위를 벗어나서 저장할 수 없음");
  }
  arrayList.add(index-1, member);
}
//==================================================
Member memberJo = new Member(1005, "조조조");
memberArrayList.insertMember(memberJo, 2);
```

## ArrayList와 Vector 클래스

- 차이점 : 동기화 지원 여부

  - Vector : 동기화 지원

    - 메소드 호출 때마다 잠금과 해제가 일어나므로 ArrayList보다 속도가 느림

  - ArrayList : 동기화 지원하지 않음

    - 만약 ArrayList를 사용하다가 동기화가 필요하면?

      ```java
      Collections.synchronizedList(new ArrayList<String>());
      ```

### 쓰레드와 멀티쓰레드 프로그래밍

- 쓰레드 : 작업단위
- 두 개 이상의 쓰레드가 동시에 실행되면 같은 메모리 공간에 접근하기 때문에 오류 발생 가능이 있습니다.
  - 이때 메모리에 동시 접근을 못하도록 방지하는 것이 동기화입니다.
  - 멀티쓰레드 환경이 아닌 경우에는 ArrayList를 사용합니다.

## LinkedList

- 배열은 자료의 삽입, 삭제 시 자료의 이동이 필요합니다.
- 링크드 리스트는 이러한 단점을 개선한 자료구조 입니다.

### 링크드 리스트의 구조

- 링크드 리스트의 각 요소는 **요소의 자료**와 다음 **요소의 주소를 저장하는 부분**으로 구분됩니다.

### 링크드 리스트에 요소 추가하기

- 원래 d노드를 가리키는 b노드가 있다고 하면,
  - c노드를 추가하고 싶을 때, b 노드의 다음 요소 주소 부분을 c로 바꾸어 줍니다.

### 링크드 리스트의 요소 제거하기

- a - b - c 로 연결된 노드들이 있다면,
  - b 노드를 삭제하고 싶을 때, a의 다음 요소부분을 c로 변경하고
  - b의 다음 요소 부분을 지워 줍니다. => 그러면 b의 연결 상태가 끊기므로 가비지컬렉션에서 메모리를 수거합니다.

### 배열과 링크드 리스트의 다른점

- 배열은 인덱스 순서로 되어 있기 때문에 '검색'이 빠릅니다.
- 링크드 리스트는 '삽입, 삭제'가 빠릅니다.

=> 자료의 변동이 거의 없는 경우는 배열을 사용하는 것이 좋습니다.

### LinkedList 클래스 사용하기

```java
package Collection.linkedlist;

import java.util.LinkedList;

public class LinkedListTest {

    public static void main(String[] args) {
        LinkedList<String> myList = new LinkedList<String>();

        myList.add("A");
        myList.add("B");
        myList.add("C");

        System.out.println(myList);

        myList.add(1, "D");
        System.out.println(myList);

        myList.addFirst("O");
        System.out.println(myList);

        System.out.println(myList.removeLast());
        System.out.println(myList);
    }
}
/*
[A, B, C]
[A, D, B, C]
[O, A, D, B, C]
C
[O, A, D, B]
*/
```

## ArrayList로 스택과 큐 구현하기

- Stack : LIFO 방식
- Queue : FIFO 방식

### ArrayList로 스택 구현하기

```java
package Collection.arraylist.stack;

import java.util.ArrayList;

class MyStack{
    private ArrayList<String> arrayStack = new ArrayList<String>();

    public void push(String data){
        arrayStack.add(data);
    }

    public String pop(){
        int len = arrayStack.size();
        if(len == 0){
            System.out.println("스택이 비었습니다.");
            return null;
        }

        return (arrayStack.remove(len - 1));
    }
}

public class StackTest {
    public static void main(String[] args) {
        MyStack stack = new MyStack();
        stack.push("A");
        stack.push("B");
        stack.push("C");

        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
}
/*
C
B
A
*/
```

- GenericsStack

```java
package Collection.arraylist.stack;

import java.util.ArrayList;

class MyGenericsStack<T>{
    private ArrayList<T> arrayStack = new ArrayList<T>();

    public void push(T data){
        arrayStack.add(data);
    }

    public T pop(){
        int len = arrayStack.size();
        if(len == 0){
            System.out.println("스택이 비었습니다.");
            return null;
        }

        return (arrayStack.remove(len - 1));
    }
}


public class GenericsStack {
    public static void main(String[] args) {
        MyGenericsStack stack = new MyGenericsStack();
        stack.push("A");
        stack.push(3);
        stack.push(true);

        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
}
```

### ArrayList로 큐 구현하기

```java
package Collection.arraylist.queue;

import java.util.ArrayList;

class MyQueue{
    private ArrayList<String> arrayQueue = new ArrayList<String>();

    public void enQueue(String data){
        arrayQueue.add(data);
    }

    public String deQueue(){
        int len = arrayQueue.size();
        if(len == 0) {
            System.out.println("큐가 비었습니다.");
            return null;
        }
        return (arrayQueue.remove(0)); //맨 앞의 자료를 반호나하고 배열에서 제거
    }
}
public class QueueTest {
    public static void main(String[] args) {
        MyQueue queue = new MyQueue();

        queue.enQueue("A");
        queue.enQueue("B");
        queue.enQueue("C");

        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
        System.out.println(queue.deQueue());
    }
}
/*
A
B
C
*/
```

## 우선순위 큐(자바의 정석)

- 저장한 순서에 관계 없이 **우선순위가 높은 순으로 꺼내되는 특징이** 있습니다. 그리고 null은 저장할 수 없습니다.
  - 우선순위가 높다 => 숫자인 경우 낮은 숫자일 수록 우선순위가 높습니다.
- 우선순위 큐는 저장공간으로 배열을 사용하며, 힙 자료구조를 이용해 자료를 저장합니다.

```java
package Collection.arraylist.queue.javastandard;

import java.util.PriorityQueue;
import java.util.Queue;

public class PriorityQueueEx {
    public static void main(String[] args) {
        Queue pq = new PriorityQueue();
        pq.offer(3);
        pq.offer(2);
        pq.offer(5);
        pq.offer(4);
        pq.offer(1);

        System.out.println("pq의 내부 출력 :" + pq);

        Object obj = null;
        //큐에 저장된 요소를 하나씩 꺼낸다
        while ((obj = pq.poll()) != null){
            System.out.println(obj);
        }
    }
}
/*
pq의 내부 출력 :[1, 2, 5, 4, 3]
1
2
3
4
5
*/
```



## Collection요소를 순회하는  Iterator

- 저장된 요소들을 순회하기 위해 사용되며, Set과 같은 순서가 없는 자료구조에서 사용됩니다.

  - Set은 get(i) 처럼 순서대로 자료를 순회할 수 없기 때문에 Iterator가 필요합니다.

  ```java
  Iterator ir = memberArrayList.iterator();
  ```

### Iterator를 사용하여 요소를 순회할 때 사용하는 메소드

- boolean hasNext() : 이후에 요소가 더 있는지 체크하는 메소드
- E next() : 다음에 있는 요소를 반환합니다.
- MemberArrayList의 removeMemeber() 메소드 수정

```java
//원래 코드
public boolean removeMember(int memberId){
  for (int i = 0; i < arrayList.size(); i++) {
    Member member = arrayList.get(i);
    int tempId = member.getMemberId();
    //회원 아이디가 매개변수와 일치하면
    if (tempId == memberId) {
      arrayList.remove(i); //해당 회원 삭제
      return true;
    }
  }
  System.out.println(memberId + "가 존재하지 않습니다.");
  return false;
}

//Iterator 이용
public boolean removeMember(int memberId){
  Iterator<Member> ir = arrayList.iterator();
	while (ir.hasNext()) {
    Member member = ir.next();
    int tempId = member.getMemberId();
    //회원 아이디가 매개변수와 일치하면
    if (tempId == memberId) {
      arrayList.remove(member); //해당 회원 삭제
      return true;
    }
  }
  System.out.println(memberId + "가 존재하지 않습니다.");
  return false;
}
```

