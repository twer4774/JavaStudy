# 12-1. 컬렉션 프레임워크 - 제너릭

## 제너릭이란

- 하나의 참조형이 아닌 여러 참조형을 매개변수로 사용할 수 있는 프로그래밍을 제너릭이라고 합니다.
  - 참조 자료형이 반환될 때 컴파일러가 검증을 하므로 안정적입니다.

## 제너릭 클래스 정의하기

```java
public class GenericPrinter<T> {
    private T material;

    public T getMaterial() {
        return material;
    }

    public void setMaterial(T material) {
        this.material = material;
    }
}
```

- 자료형 매개변수 T와 static => static으로 제너릭을 사용할 수 없다
  - static 변수는 인스턴스 변수가 생성되기 이전에 생성됩니다.
  - T의 자료형이 정해지는 순간은 제너릭 클래스의 인스턴스가 생성되는 순간입니다.
    - 따라서 T의 자료형이 결정되는 시점보다 빠르기 때문에 static 변수의 자료형이나 static 메소드 내부의 변수의 자료형으로 T를 사용할 수 없습니다.

## 제너릭 클래스 사용하기

```java
GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
powderPrinter.setMaterial(new Powder());
Powder powder = powderPrinter.getMaterial(); //명시적 형 변환을 하지 않음
```

- 제너릭은 형변환을 하지 않습니다.
  - 컴파일러가 대입된 자료형이 잘 쓰였는지 확인 후 class 파일을 생성할 때 T를 사용한 곳에 지정된 자료형에 따라 컴파일하므로 형변환을 하지 않아도 됩니다. => 컴파일러가 제너릭 부분에 자동으로 알맞는 형으로 변환해준다. 

```java
package Generics;

public class Powder {
    public void doPrinting(){
        System.out.println("Powder 재료로 출력합니다.");
    }

    public String toString(){
        return "재료는 Powder";
    }
}
//=======================================================
package Generics;

public class Plastic {
    public void doPrinting(){
        System.out.println("plastic 재료로 출력합니다.");
    }

    public String toString(){
        return "재료는 Plastic";
    }
}
//=======================================================
package Generics;

public class GenericPrinter<T> {
    private T material;

    public T getMaterial() {
        return material;
    }

    public void setMaterial(T material) {
        this.material = material;
    }

    public String toString(){
        return material.toString();
    }

}
//=======================================================
package Generics;

public class GenericPrinterTest {

    public static void main(String[] args) {
        GenericPrinter<Powder> powderGenericPrinter = new GenericPrinter<Powder>();

        powderGenericPrinter.setMaterial(new Powder());
        Powder powder = powderGenericPrinter.getMaterial();
        System.out.println(powderGenericPrinter);


        GenericPrinter<Plastic> plasticGenericPrinter = new GenericPrinter<Plastic>();

        plasticGenericPrinter.setMaterial(new Plastic());
        Plastic plastic = plasticGenericPrinter.getMaterial();
        System.out.println(plasticGenericPrinter);
    }

}
```

## T 자료형에 사용할 자료형을 제한하는 <T extends 클래스>

- T 자료형에 사용할 자료형에 제한을 둘 수 있습니다.

  - 만약 위의 예에서 파우더, 플라스틱 대신 물을 넣게 되면 프린터는 바르게 동작하지 않습니다.
  - 따라서 \<T extends Material>을 이용해 파우더와 플라스틱으로 T 자료형을 한정시킬 수 있습니다.

  ```java
  public abstract class Material {
      public abstract void doPrinting();
  }
  //=================================================
  public class Plastic extends Material{ }
  //=================================================
  public class Powder extends Material{ }
  //=================================================
  public class GenericPrinter<T extends Material> { }
  ```

## 제너릭 메소드 활용하기

- 제너릭 클래스가 아니더라도 내부에 제너릭 메소드를 구현할 수 있습니다.

```java
package Generics.GenericMethod;

public class Point<T, V> {
    T x;
    V y;

    Point(T x, V y){
        this.x = x;
        this.y = y;
    }

    public T getX(){
        return x;
    }

    public V getY(){
        return y;
    }
}
//==================================
package Generics.GenericMethod;

public class GenericMethod {
    public static <T, V> double makeRectangle(Point<T, V> p1, Point<T, V> p2){
        double left = ((Number) p1.getX()).doubleValue();
        double right = ((Number) p2.getX()).doubleValue();
        double top = ((Number) p1.getY()).doubleValue();
        double bottom = ((Number) p2.getY()).doubleValue();

        double width = right - left;
        double height = bottom - top;

        return width * height;
    }

    public static void main(String[] args) {
        Point<Integer, Double> p1 = new Point<Integer, Double>(0, 0.0);
        Point<Integer, Double> p2 = new Point<>(10, 10.0);

//문법이 눈에 안익는다. 그냥 메소드를 호출하는데 리턴타입을 넣어야함(생략해도 컴파일러가 알아서 유추함)
//        double rect = GenericMethod.<Integer, Double>makeRectangle(p1, p2);
        double rect = GenericMethod.makeRectangle(p1, p2);
        System.out.println("두 점으로 만들어진 사각형의 넓이는 " + rect);
    }

}
/*
두 점으로 만들어진 사각형의 넓이는 100.0
*/
```

